{{"// Code generated by boxrecordc, DO NOT EDIT."}}

package {{ .Package }}

import (
	"context"
	"fmt"

	"github.com/lomik/go-tnt"
)

// todo lowercase first letter
type {{$.BoxName}} struct {
{{range $index, $field := .Fields}} {{ printf "\t%s %s\n" $field.Name $field.Type }} {{end}}
	updateOps []tnt.Operator
	exists, deleted bool // todo check this flags on inserts and updates
}

const BoxSpace = {{.Space}}

func (record *{{$.BoxName}}) String() string {
	return fmt.Sprintf(
		"{{range $index, $field := .Fields}} {{ printf "%s=%%s " $field.Name }} {{end}}",
		{{range $index, $field := .Fields}} {{ printf "string(record.%s),\n" $field.Name }} {{end}}
	)
}

// todo uppercase first letter
type {{$.BoxName}}Fields struct {
	{{range $index, $field := .Fields}}
	{{ printf "%s %s" $field.Name $field.Type  }}
	{{end}}
}

func (record *{{$.BoxName}}) Equals(other *{{$.BoxName}}) bool {
	// так костыльно, потому что в гошных шаблонах такое условие типа rec.f1 == other.f1 || ... будет следать сильно сложнее
	{{range $index, $field := .Fields}}
	{{ printf "if record.%s != other.%s {\n\t\treturn false\n\t}" $field.Name $field.Name }}
	{{end}}
	return true
}

// todo а что будет, если тут будет несколько операций с одним и тем же полем?
{{range $index, $field := .SecondaryFields}}
func (record *{{$.BoxName}}) Set{{$field.Name}}(new{{$field.Name}} {{$field.Type}}) {
	if record.{{$field.Name}} == new{{$field.Name}} {
		return
	}
	record.{{$field.Name}} = new{{$field.Name}}

	record.updateOps = append(record.updateOps, tnt.OpSet({{$field.FieldNo}}, {{$field.PackFunc}}(record.{{$field.Name}})))
	return
}
{{end}}


func (record *{{$.BoxName}}) Update(ctx context.Context, conn *tnt.Connection) error {
	if len(record.updateOps) == 0 {
		return nil
	}

	//todo get returned tuple and update current one
	_, err := conn.Exec(ctx, &tnt.Update{
		Space: BoxSpace,
		Tuple: tnt.Tuple{
			{{range $index, $field := .PrimaryIndex.FieldsStucts}}
			{{$field.PackFunc}}(record.{{$field.Name}}),
			{{end}}
		},
		Ops: record.updateOps,
		ReturnTuple: true,
	})

	record.updateOps = record.updateOps[:0]
	return err
}

func Create(ctx context.Context, conn *tnt.Connection, tupleFields *{{$.BoxName}}Fields) (*{{$.BoxName}}, error) {
	tuple := tnt.Tuple{
		{{range $index, $field := .Fields}}
		{{$field.PackFunc}}(tupleFields.{{$field.Name}}),
		{{end}}
	}
	_, err := conn.Exec(ctx, &tnt.Insert{
		Space: BoxSpace,
		Tuple: tuple,
	})
	if err != nil {
		return nil, err
	}

	return &{{$.BoxName}}{
		{{range $index, $field := .Fields}}
		{{printf "%s: tupleFields.%s," $field.Name $field.Name}}
		{{end}}
	}, nil
}

func (record *{{$.BoxName}}) Delete(ctx context.Context, conn *tnt.Connection) error {
	_, err := conn.Exec(ctx, &tnt.Delete{
		Space: BoxSpace,
		Tuple: tnt.Tuple{
			{{range $index, $field := .PrimaryIndex.FieldsStucts}}
			{{$field.PackFunc}}(record.{{$field.Name}}),
			{{end}}
		},
	})

	return err
}


{{range $i, $index := .Indexes}}
type {{ $index.Name }}Key struct {
	{{range $index, $field := $index.FieldsStucts}}
	{{ printf "%s %s" $field.Name $field.Type  }}
	{{end}}
}

func (record *{{$.BoxName}}) {{$index.Name}}Key() *{{$index.Name}}Key {
	return &{{$index.Name}}Key{
		{{range $index, $field := .FieldsStucts}}
		{{ printf "%s: record.%s," $field.Name $field.Name }}
		{{end}}
	}}


func SelectBy{{$index.Name}}(ctx context.Context, conn *tnt.Connection, idxKey *{{ $index.Name }}Key) ({{if not $index.Uniq}}[]{{end}}*{{$.BoxName}}, error) {
	idxTuple := tnt.Tuple{
		{{range $i, $field := $index.FieldsStucts}}
		{{printf "%s(idxKey.%s)," $field.PackFunc $field.Name}}
		{{end}}
	}
	res, err := conn.Exec(ctx, &tnt.Select{
		Space: BoxSpace,
		Index:  0,
		Tuples: []tnt.Tuple{idxTuple},
	})
	if err != nil {
		return nil, err
	}

	if len(res) == 0 {
		return nil, fmt.Errorf("no items found") // todo to ErrNoItems like xo
	}

	{{if $index.Uniq}}
	// todo это же правильно?
	if len(res) > 1 {
		panic("First index for box {{$.BoxName}} expected to be uniq!")
	}

	selectedTuple := res[0]
	record := &{{$.BoxName}}{}

	err = parse{{$.BoxName}}Tuple(selectedTuple, record)
	if err != nil {
		return nil, err
	}

	return record, nil
	{{else}}

	records := make([]{{$.BoxName}}, len(res))
	recordsPtrs := make([]*{{$.BoxName}}, 0, len(res))
	for i, selectedTuple := range res {

		record := records[i]
		err := parse{{$.BoxName}}Tuple(selectedTuple, &record)
		if err != nil {
			return nil, err
		}

		recordsPtrs = append(recordsPtrs, &record)
	}

	return recordsPtrs, nil
	{{end}}
}

func SelectMultiBy{{$index.Name}}(ctx context.Context, conn *tnt.Connection, idxKeys []*{{ $index.Name }}Key) ([]*{{$.BoxName}}, error) {

	if len(idxKeys) == 0 {
		return nil, nil
	}

	selectTuples := make([]tnt.Tuple, len(idxKeys))
	for i, idxKey := range idxKeys {
		selectTuples[i] = append(selectTuples[i],
			{{range $i, $field := $index.FieldsStucts}}
			{{printf "%s(idxKey.%s)," $field.PackFunc $field.Name}}
			{{end}}
		)
	}

	selectRes, err := conn.Exec(ctx, &tnt.Select{
		Space: BoxSpace,
		Index:  0,
		Tuples: selectTuples,
	})

	if err != nil {
		return nil, err
	}

	fmt.Printf("%d\n", len(selectRes));

	if len(selectRes) == 0 {
		return nil, nil
	}

	records := make([]{{$.BoxName}}, len(selectRes))
	recordsPtrs := make([]*{{$.BoxName}}, 0, len(selectRes))
	for i, selectedTuple := range selectRes {

		record := records[i]
		err := parse{{$.BoxName}}Tuple(selectedTuple, &record)
		if err != nil {
			return nil, err
		}

		recordsPtrs = append(recordsPtrs, &record)
	}

	return recordsPtrs, nil
}
{{end}}

func parse{{$.BoxName}}Tuple(selectedTuple tnt.Tuple, record *{{$.BoxName}}) error {

	// unpack index fields
	primaryIndexCardinality := {{ len $.PrimaryIndex.FieldsStucts }}
	if len(selectedTuple) < primaryIndexCardinality {
		return fmt.Errorf("selected tuple cardinality mismatch. Expected at least %d elements in tuple. Got: %x", primaryIndexCardinality, len(selectedTuple))
	}

	{{range $i, $field := $.PrimaryIndex.FieldsStucts}}
	{{if gt $field.Size 0}}
	if len(selectedTuple[{{$i}}]) != {{$field.Size}} {
		return fmt.Errorf("{{$.BoxName}}: index (primary idx) field %d expected to be {{$field.Type}} with size of {{$field.Size}} bytes. Got (length %d): %x", {{$i}}, len(selectedTuple[{{$i}}]), selectedTuple[{{$i}}])
	}
	{{end}}
	record.{{$field.Name}} = {{$field.UnpackFunc}}(selectedTuple[{{$i}}])
	{{end}}
	/* todo поддержать другие индексы */

	// unpack another fields only if they are in box
	for i := primaryIndexCardinality; i < len(selectedTuple); i++ {
		switch i {
		{{range $i, $field := $.SecondaryFields}}
		case {{$field.FieldNo}}:
		{{if gt $field.Size 0}}
			if len(selectedTuple[i]) != {{$field.Size}} {
				return fmt.Errorf("{{$.BoxName}}: index field %d expected to be {{$field.Type}} with size of {{$field.Size}} bytes. Got: (length %d) %x", i, len(selectedTuple[i]), selectedTuple[i])
			}
		{{end}}
			record.{{$field.Name}} = {{$field.UnpackFunc}}(selectedTuple[i])
		{{end}}
		default:
			// found new field that was not described by golang struct
			break
		}
	}
	return nil
}
